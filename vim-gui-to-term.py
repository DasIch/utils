#!/usr/bin/env python
# coding: utf-8
"""
    vim-gui-to-term
    ~~~~~~~~~~~~~~~

    This script converts trivial vim colorschemes designed to work in gvim to
    colorschemes that are not only usable in gvim but also in vim using the
    closest colors that could be found.

    The generated colorscheme uses 256 colors.

    Dependencies:

        - colormath

    :license: BSD, see LICENSE for details
    :copyright: 2010 by Daniel Neuh√§user
"""
import re
import sys
from optparse import OptionParser
from itertools import izip_longest, takewhile

from colormath.color_objects import RGBColor


highlight_re = re.compile(
    ur'hi\s+([A-zA-Z0-9]+)\s*' + '(?:([^\s=]+)=([^\s]+)\s*)?' * 3
)


KEY_ORDER = dict((k, i) for i, k in enumerate(
    ('guifg', 'ctermfg', 'guibg', 'ctermbg', 'gui', 'term')
))
GUI_COLOR_KEYS = frozenset(('guifg', 'guibg'))
TERM_COLOR_KEYS = frozenset(('ctermfg', 'ctermbg'))
COLOR_KEYS = GUI_COLOR_KEYS.union(TERM_COLOR_KEYS)
COLOR_KEY_MAPPING = {
    'guifg': 'ctermfg',
    'guibg': 'ctermbg'
}
missing = object()
COLORS = [
    # system colors
    (0x00, 0x00, 0x00), # black
    (0x80, 0x00, 0x00), # dark red
    (0x00, 0x80, 0x00), # dark green
    (0x80, 0x80, 0x00), # dark yellow
    (0x00, 0x00, 0x80), # dark blue
    (0x80, 0x00, 0x80), # dark magenta
    (0x00, 0x80, 0x80), # dark cyan
    (0xc0, 0xc0, 0xc0), # light grey
    (0x80, 0x80, 0x80), # dark grey
    (0xff, 0x00, 0x00), # light red
    (0x00, 0xff, 0x00), # light green
    (0xff, 0xff, 0x00), # light yellow
    (0x00, 0x00, 0xff), # light blue
    (0xff, 0x00, 0xff), # light magenta
    (0x00, 0xff, 0xff), # light cyan
    (0xff, 0xff, 0xff), # white
    # rgb colors
    (0x00, 0x00, 0x00),
    (0x00, 0x00, 0x5f),
    (0x00, 0x00, 0x87),
    (0x00, 0x00, 0xaf),
    (0x00, 0x00, 0xdf),
    (0x00, 0x00, 0xff),
    (0x00, 0x5f, 0x00),
    (0x00, 0x5f, 0x5f),
    (0x00, 0x5f, 0x87),
    (0x00, 0x5f, 0xaf),
    (0x00, 0x5f, 0xdf),
    (0x00, 0x5f, 0xff),
    (0x00, 0x87, 0x00),
    (0x00, 0x87, 0x5f),
    (0x00, 0x87, 0x87),
    (0x00, 0x87, 0xaf),
    (0x00, 0x87, 0xdf),
    (0x00, 0x87, 0xff),
    (0x00, 0xaf, 0x00),
    (0x00, 0xaf, 0x5f),
    (0x00, 0xaf, 0x87),
    (0x00, 0xaf, 0xaf),
    (0x00, 0xaf, 0xdf),
    (0x00, 0xaf, 0xff),
    (0x00, 0xdf, 0x00),
    (0x00, 0xdf, 0x5f),
    (0x00, 0xdf, 0x87),
    (0x00, 0xdf, 0xaf),
    (0x00, 0xdf, 0xdf),
    (0x00, 0xdf, 0xff),
    (0x00, 0xff, 0x00),
    (0x00, 0xff, 0x5f),
    (0x00, 0xff, 0x87),
    (0x00, 0xff, 0xaf),
    (0x00, 0xff, 0xdf),
    (0x00, 0xff, 0xff),
    (0x5f, 0x00, 0x00),
    (0x5f, 0x00, 0x5f),
    (0x5f, 0x00, 0x87),
    (0x5f, 0x00, 0xaf),
    (0x5f, 0x00, 0xdf),
    (0x5f, 0x00, 0xff),
    (0x5f, 0x5f, 0x00),
    (0x5f, 0x5f, 0x5f),
    (0x5f, 0x5f, 0x87),
    (0x5f, 0x5f, 0xaf),
    (0x5f, 0x5f, 0xdf),
    (0x5f, 0x5f, 0xff),
    (0x5f, 0x87, 0x00),
    (0x5f, 0x87, 0x5f),
    (0x5f, 0x87, 0x87),
    (0x5f, 0x87, 0xaf),
    (0x5f, 0x87, 0xdf),
    (0x5f, 0x87, 0xff),
    (0x5f, 0xaf, 0x00),
    (0x5f, 0xaf, 0x5f),
    (0x5f, 0xaf, 0x87),
    (0x5f, 0xaf, 0xaf),
    (0x5f, 0xaf, 0xdf),
    (0x5f, 0xaf, 0xff),
    (0x5f, 0xdf, 0x00),
    (0x5f, 0xdf, 0x5f),
    (0x5f, 0xdf, 0x87),
    (0x5f, 0xdf, 0xaf),
    (0x5f, 0xdf, 0xdf),
    (0x5f, 0xdf, 0xff),
    (0x5f, 0xff, 0x00),
    (0x5f, 0xff, 0x5f),
    (0x5f, 0xff, 0x87),
    (0x5f, 0xff, 0xaf),
    (0x5f, 0xff, 0xdf),
    (0x5f, 0xff, 0xff),
    (0x87, 0x00, 0x00),
    (0x87, 0x00, 0x5f),
    (0x87, 0x00, 0x87),
    (0x87, 0x00, 0xaf),
    (0x87, 0x00, 0xdf),
    (0x87, 0x00, 0xff),
    (0x87, 0x5f, 0x00),
    (0x87, 0x5f, 0x5f),
    (0x87, 0x5f, 0x87),
    (0x87, 0x5f, 0xaf),
    (0x87, 0x5f, 0xdf),
    (0x87, 0x5f, 0xff),
    (0x87, 0x87, 0x00),
    (0x87, 0x87, 0x5f),
    (0x87, 0x87, 0x87),
    (0x87, 0x87, 0xaf),
    (0x87, 0x87, 0xdf),
    (0x87, 0x87, 0xff),
    (0x87, 0xaf, 0x00),
    (0x87, 0xaf, 0x5f),
    (0x87, 0xaf, 0x87),
    (0x87, 0xaf, 0xaf),
    (0x87, 0xaf, 0xdf),
    (0x87, 0xaf, 0xff),
    (0x87, 0xdf, 0x00),
    (0x87, 0xdf, 0x5f),
    (0x87, 0xdf, 0x87),
    (0x87, 0xdf, 0xaf),
    (0x87, 0xdf, 0xdf),
    (0x87, 0xdf, 0xff),
    (0x87, 0xff, 0x00),
    (0x87, 0xff, 0x5f),
    (0x87, 0xff, 0x87),
    (0x87, 0xff, 0xaf),
    (0x87, 0xff, 0xdf),
    (0x87, 0xff, 0xff),
    (0xaf, 0x00, 0x00),
    (0xaf, 0x00, 0x5f),
    (0xaf, 0x00, 0x87),
    (0xaf, 0x00, 0xaf),
    (0xaf, 0x00, 0xdf),
    (0xaf, 0x00, 0xff),
    (0xaf, 0x5f, 0x00),
    (0xaf, 0x5f, 0x5f),
    (0xaf, 0x5f, 0x87),
    (0xaf, 0x5f, 0xaf),
    (0xaf, 0x5f, 0xdf),
    (0xaf, 0x5f, 0xff),
    (0xaf, 0x87, 0x00),
    (0xaf, 0x87, 0x5f),
    (0xaf, 0x87, 0x87),
    (0xaf, 0x87, 0xaf),
    (0xaf, 0x87, 0xdf),
    (0xaf, 0x87, 0xff),
    (0xaf, 0xaf, 0x00),
    (0xaf, 0xaf, 0x5f),
    (0xaf, 0xaf, 0x87),
    (0xaf, 0xaf, 0xaf),
    (0xaf, 0xaf, 0xdf),
    (0xaf, 0xaf, 0xff),
    (0xaf, 0xdf, 0x00),
    (0xaf, 0xdf, 0x5f),
    (0xaf, 0xdf, 0x87),
    (0xaf, 0xdf, 0xaf),
    (0xaf, 0xdf, 0xdf),
    (0xaf, 0xdf, 0xff),
    (0xaf, 0xff, 0x00),
    (0xaf, 0xff, 0x5f),
    (0xaf, 0xff, 0x87),
    (0xaf, 0xff, 0xaf),
    (0xaf, 0xff, 0xdf),
    (0xaf, 0xff, 0xff),
    (0xdf, 0x00, 0x00),
    (0xdf, 0x00, 0x5f),
    (0xdf, 0x00, 0x87),
    (0xdf, 0x00, 0xaf),
    (0xdf, 0x00, 0xdf),
    (0xdf, 0x00, 0xff),
    (0xdf, 0x5f, 0x00),
    (0xdf, 0x5f, 0x5f),
    (0xdf, 0x5f, 0x87),
    (0xdf, 0x5f, 0xaf),
    (0xdf, 0x5f, 0xdf),
    (0xdf, 0x5f, 0xff),
    (0xdf, 0x87, 0x00),
    (0xdf, 0x87, 0x5f),
    (0xdf, 0x87, 0x87),
    (0xdf, 0x87, 0xaf),
    (0xdf, 0x87, 0xdf),
    (0xdf, 0x87, 0xff),
    (0xdf, 0xaf, 0x00),
    (0xdf, 0xaf, 0x5f),
    (0xdf, 0xaf, 0x87),
    (0xdf, 0xaf, 0xaf),
    (0xdf, 0xaf, 0xdf),
    (0xdf, 0xaf, 0xff),
    (0xdf, 0xdf, 0x00),
    (0xdf, 0xdf, 0x5f),
    (0xdf, 0xdf, 0x87),
    (0xdf, 0xdf, 0xaf),
    (0xdf, 0xdf, 0xdf),
    (0xdf, 0xdf, 0xff),
    (0xdf, 0xff, 0x00),
    (0xdf, 0xff, 0x5f),
    (0xdf, 0xff, 0x87),
    (0xdf, 0xff, 0xaf),
    (0xdf, 0xff, 0xdf),
    (0xdf, 0xff, 0xff),
    (0xff, 0x00, 0x00),
    (0xff, 0x00, 0x5f),
    (0xff, 0x00, 0x87),
    (0xff, 0x00, 0xaf),
    (0xff, 0x00, 0xdf),
    (0xff, 0x00, 0xff),
    (0xff, 0x5f, 0x00),
    (0xff, 0x5f, 0x5f),
    (0xff, 0x5f, 0x87),
    (0xff, 0x5f, 0xaf),
    (0xff, 0x5f, 0xdf),
    (0xff, 0x5f, 0xff),
    (0xff, 0x87, 0x00),
    (0xff, 0x87, 0x5f),
    (0xff, 0x87, 0x87),
    (0xff, 0x87, 0xaf),
    (0xff, 0x87, 0xdf),
    (0xff, 0x87, 0xff),
    (0xff, 0xaf, 0x00),
    (0xff, 0xaf, 0x5f),
    (0xff, 0xaf, 0x87),
    (0xff, 0xaf, 0xaf),
    (0xff, 0xaf, 0xdf),
    (0xff, 0xaf, 0xff),
    (0xff, 0xdf, 0x00),
    (0xff, 0xdf, 0x5f),
    (0xff, 0xdf, 0x87),
    (0xff, 0xdf, 0xaf),
    (0xff, 0xdf, 0xdf),
    (0xff, 0xdf, 0xff),
    (0xff, 0xff, 0x00),
    (0xff, 0xff, 0x5f),
    (0xff, 0xff, 0x87),
    (0xff, 0xff, 0xaf),
    (0xff, 0xff, 0xdf),
    (0xff, 0xff, 0xff),
    # greyscale
    (0x08, 0x08, 0x08),
    (0x12, 0x12, 0x12),
    (0x1c, 0x1c, 0x1c),
    (0x26, 0x26, 0x26),
    (0x30, 0x30, 0x30),
    (0x3a, 0x3a, 0x3a),
    (0x44, 0x44, 0x44),
    (0x4e, 0x4e, 0x4e),
    (0x58, 0x58, 0x58),
    (0x60, 0x60, 0x60),
    (0x66, 0x66, 0x66),
    (0x76, 0x76, 0x76),
    (0x80, 0x80, 0x80),
    (0x8a, 0x8a, 0x8a),
    (0x94, 0x94, 0x94),
    (0x9e, 0x9e, 0x9e),
    (0xa8, 0xa8, 0xa8),
    (0x9e, 0x9e, 0x9e),
    (0xa8, 0xa8, 0xa8),
    (0xb2, 0xb2, 0xb2),
    (0xbc, 0xbc, 0xbc),
    (0xc6, 0xc6, 0xc6),
    (0xd0, 0xd0, 0xd0),
    (0xda, 0xda, 0xda),
    (0xe4, 0xe4, 0xe4),
    (0xee, 0xee, 0xee)
]
INDEX_TO_COLOR = dict(enumerate(COLORS))
COLOR_TO_INDEX = dict((v, k) for k, v in INDEX_TO_COLOR.iteritems())



def groups(n, iterable, fillvalue=None):
    return izip_longest(fillvalue=fillvalue, *([iter(iterable)] * n))


def parse_highlight(line):
    parts = highlight_re.match(line).groups()
    rv = {'name': parts[0]}
    rv.update(groups(2, takewhile(lambda x: x is not None, parts[1:])))
    for key, value in rv.iteritems():
        if key in GUI_COLOR_KEYS:
            try:
                rv[key] = Color.from_string(value)
            except ValueError:
                if value == 'NONE':
                    rv[key] = NullColor()
                else:
                    raise
    return rv


class NullColor(object):
    def to_string(self):
        return 'NONE'

    def to_int(self):
        return 'NONE'

    def __eq__(self, other):
        return isinstance(other, self.__class__)

    def __ne__(self, other):
        return not self.__eq__(other)

    def difference_to(self, color):
        raise NotImplementedError()

    def closest(self, colors):
        raise NotImplementedError()


class Color(object):
    @classmethod
    def from_string(cls, string):
        if not string.startswith('#'):
            raise ValueError(string)
        if len(string) == 4:
            args = [int(x * 2, 16) for x in string[1:]]
        elif len(string) == 7:
            args = [int(string[i:i + 2], 16) for i in xrange(1, 7, 2)]
        else:
            raise ValueError(string)
        return cls(*args)

    @classmethod
    def from_index(cls, index):
        return cls(*INDEX_TO_COLOR[index])

    def __init__(self, red, green, blue):
        self.color = RGBColor(red, green, blue)

    @property
    def red(self):
        return self.color.rgb_r

    @property
    def green(self):
        return self.color.rgb_g

    @property
    def blue(self):
        return self.color.rgb_b

    def __eq__(self, other):
        return self.to_int() == other.to_int()

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return self.to_int()

    def to_string(self):
        return self.color.get_rgb_hex()

    def to_int(self):
        return COLOR_TO_INDEX[self.red, self.green, self.blue]

    def difference_to(self, color):
        return self.color.delta_e(color.color)

    def closest(self, colors):
        rv = {}
        for color in colors:
            rv[color.difference_to(self)] = color
        return rv[min(rv)]


allowed_colors = frozenset(Color.from_index(i) for i in xrange(256))


def highlight_to_string(highlight):
    rv = ['hi', highlight.pop('name')]
    highlight = highlight.items()
    highlight.sort(key=lambda i: KEY_ORDER[i[0]])
    for key, value in highlight:
        if key in GUI_COLOR_KEYS:
            value = value.to_string()
        elif key in TERM_COLOR_KEYS:
            value = value.to_int()
        rv.append('{0}={1}'.format(key, value))
    return ' '.join(rv) + '\n'


def convert_highlight(highlight):
    rv = {}
    for key, value in highlight.iteritems():
        if key in GUI_COLOR_KEYS:
            try:
                rv[COLOR_KEY_MAPPING[key]] = value.closest(allowed_colors)
            except NotImplementedError:
                pass
    if 'gui' in highlight and 'term' not in highlight:
        highlight['term'] = highlight['gui']
    highlight.update(rv)


def convert_file(infile, outfile):
    for line in infile:
        if line.startswith('hi'):
            highlight = parse_highlight(line)
            convert_highlight(highlight)
            line = highlight_to_string(highlight)
        outfile.write(line)


def main(argv=sys.argv):
    parser = OptionParser()
    parser.add_option('-o', '--out', dest='outfile', help='write to file',
                      metavar='FILE')
    options, args = parser.parse_args()
    if len(args) != 1:
        parser.error('one and only one input file is required')
    if options.outfile:
        outfile = open(options.outfile, 'w')
        close_outfile = True
    else:
        outfile = sys.stdout
        close_outfile = False

    try:
        with open(args[0]) as infile:
            convert_file(infile, outfile)
    finally:
        if close_outfile:
            outfile.close()


if __name__ == '__main__':
    main()
